---
source: chainsight-cdk-macros/src/canisters/event_indexer.rs
expression: formatted
---
use candid::CandidType;
use chainsight_cdk::{
    core::U256,
    indexer::{Event, Indexer, IndexingConfig},
    storage::Data,
    web3::Web3CtxParam,
};
use chainsight_cdk_macros::{
    chainsight_common, define_get_ethereum_address, define_transform_for_web3, define_web3_ctx,
    did_export, init_in, manage_single_state, prepare_stable_structure, setup_func,
    timer_task_func, web3_event_indexer, web3_event_indexer_source, CborSerde, ContractEvent,
    Persist, StableMemoryStorable,
};
use ic_solidity_bindgen::types::EventLog;
use ic_stable_structures::writer::Writer;
use ic_web3_rs::{
    ethabi::Address,
    futures::{future::BoxFuture, FutureExt},
    transports::ic_http_client::CallOptions,
};
use serde::Serialize;
use std::{collections::HashMap, str::FromStr};
did_export!("app");
chainsight_common!();
define_web3_ctx!();
define_transform_for_web3!();
define_get_ethereum_address!();
prepare_stable_structure!();
timer_task_func!("set_task", "index");
manage_single_state!("target_addr", String, false);
setup_func ! ({ target_addr : String , web3_ctx_param : Web3CtxParam , config : IndexingConfig , });
init_in!();
ic_solidity_bindgen::contract_abi!("examples/minimum_indexers/src/event_indexer/abi/ERC20.json");
web3_event_indexer_source!(Transfer);
web3_event_indexer!(Transfer);
#[derive(Clone, Debug, Default, candid :: CandidType, ContractEvent, Serialize, Persist)]
pub struct Transfer {
    pub from: String,
    pub to: String,
    pub value: U256,
}
impl chainsight_cdk::indexer::Event<EventLog> for Transfer {
    fn tokenize(&self) -> chainsight_cdk::storage::Data {
        self._tokenize()
    }
    fn untokenize(data: chainsight_cdk::storage::Data) -> Self {
        Transfer::_untokenize(data)
    }
}
fn get_logs(
    from: u64,
    to: u64,
    call_options: CallOptions,
) -> BoxFuture<'static, Result<HashMap<u64, Vec<EventLog>>, chainsight_cdk::indexer::Error>> {
    async move {
        let res = ERC20::new(
            Address::from_str(get_target_addr().as_str())
                .expect("Failed to parse target addr to Address"),
            &web3_ctx().expect("Failed to get web3_ctx"),
        )
        .event_transfer(from, to, call_options)
        .await;
        match res {
            Ok(logs) => Ok(logs),
            Err(e) => Err(chainsight_cdk::indexer::Error::OtherError(e.to_string())),
        }
    }
    .boxed()
}
#[derive(
    Clone,
    Debug,
    PartialEq,
    candid :: CandidType,
    serde :: Serialize,
    serde :: Deserialize,
    CborSerde,
)]
pub struct UpgradeStableState {
    pub proxy: candid::Principal,
    pub initialized: bool,
    pub env: chainsight_cdk::core::Env,
    pub target_addr: String,
    pub web3_ctx_param: Web3CtxParam,
    pub config: IndexingConfig,
    pub indexing_interval: u32,
}
#[ic_cdk::pre_upgrade]
fn pre_upgrade() {
    ic_cdk::println!("start: pre_upgrade");
    let state = UpgradeStableState {
        proxy: get_proxy(),
        initialized: is_initialized(),
        env: get_env(),
        web3_ctx_param: get_web3_ctx_param(),
        target_addr: get_target_addr(),
        config: get_config(),
        indexing_interval: get_indexing_interval(),
    };
    let state_bytes = state.to_cbor();
    let len = state_bytes.len() as u32;
    let mut memory = get_upgrades_memory();
    let mut writer = Writer::new(&mut memory, 0);
    writer.write(&len.to_le_bytes()).unwrap();
    writer.write(&state_bytes).unwrap();
    ic_cdk::println!("finish: pre_upgrade");
}
#[ic_cdk::post_upgrade]
fn post_upgrade() {
    ic_cdk::println!("start: post_upgrade");
    let memory = get_upgrades_memory();
    let mut state_len_bytes = [0; 4];
    memory.read(0, &mut state_len_bytes);
    let state_len = u32::from_le_bytes(state_len_bytes) as usize;
    let mut state_bytes = vec![0; state_len];
    memory.read(4, &mut state_bytes);
    let state = UpgradeStableState::from_cbor(&state_bytes);
    set_initialized(state.initialized);
    set_proxy(state.proxy);
    set_env(state.env);
    setup(state.target_addr, state.web3_ctx_param, state.config)
        .expect("Failed to `setup` in post_upgrade");
    set_indexing_interval(state.indexing_interval);
    ic_cdk::println!("finish: post_upgrade");
}

