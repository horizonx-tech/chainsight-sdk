---
source: chainsight-cdk-macros/src/indexers/mod.rs
expression: formatted
---
#[ic_cdk::query]
#[candid::candid_method(query)]
fn get_sources(
) -> Vec<chainsight_cdk::core::Sources<chainsight_cdk::core::Web3EventIndexerSourceAttrs>> {
    vec![chainsight_cdk::core::Sources::<
        chainsight_cdk::core::Web3EventIndexerSourceAttrs,
    >::new_event_indexer(
        get_target_addr(),
        get_indexing_interval(),
        chainsight_cdk::core::Web3EventIndexerSourceAttrs {
            chain_id: get_web3_ctx_param().chain_id,
            event_name: "Transfer".to_string(),
        },
    )]
}
manage_single_state!("config", IndexingConfig, false);
#[ic_cdk::query]
#[candid::candid_method(query)]
pub fn events_from_to(from: u64, to: u64) -> HashMap<u64, Vec<Transfer>> {
    _events_from_to((from, to))
}
#[ic_cdk::query]
#[candid::candid_method(query)]
pub fn events_latest_n(n: u64) -> HashMap<u64, Vec<Transfer>> {
    let last_indexed = indexer().get_last_indexed().unwrap();
    _events_from_to((last_indexed - n, last_indexed))
}
fn _events_from_to(input: (u64, u64)) -> HashMap<u64, Vec<Transfer>> {
    indexer().between(input.0, input.1).unwrap()
}
#[ic_cdk::query]
#[candid::candid_method(query)]
pub fn get_last_indexed() -> u64 {
    indexer().get_last_indexed().unwrap()
}
#[ic_cdk::update]
#[candid::candid_method(update)]
async fn proxy_call(input: std::vec::Vec<u8>) -> std::vec::Vec<u8> {
    use chainsight_cdk::rpc::Receiver;
    chainsight_cdk::rpc::ReceiverProvider::<(u64, u64), HashMap<u64, Vec<Transfer>>>::new(
        proxy(),
        _events_from_to.clone(),
    )
    .reply(input)
    .await
}
fn indexer() -> chainsight_cdk::web3::Web3Indexer<Transfer> {
    chainsight_cdk::web3::Web3Indexer::new(get_logs, None)
}
#[ic_cdk::update]
#[candid::candid_method(update)]
async fn index() {
    if ic_cdk::caller() != proxy() {
        panic!("Not permitted")
    }
    indexer().index(get_config()).await.unwrap();
}

